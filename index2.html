<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Ack-Ack (10 landed then attack + shootable chutes + bombers)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            background: #000
        }

        canvas {
            display: block;
            margin: 0 auto;
            image-rendering: pixelated
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>

<body>

    <script>
        const W = 960, H = 540;

        /* Apple II–ish palette */
        const PAL = {
            BLACK: 0x000000, DKBLUE: 0x0A0B2E,
            BLUE: 0x1F56FF, PURPLE: 0xB300FF,
            GREEN: 0x32FF6A, DKGREEN: 0x0D6B2E,
            ORANGE: 0xFF8A1F, YELLOW: 0xFFE35A,
            MAGENTA: 0xFF2BD6, WHITE: 0xFFFFFF
        };

        /* ---------- Atari CRT FX ---------- */
        class AtariFX {
            constructor(scene) {
                this.g = scene.add.graphics().setDepth(999);
                this.phase = 0;
            }
            draw() {
                this.g.clear();
                this.phase += 0.07;

                this.g.lineStyle(1, 0x000000, 0.2);
                for (let y = 0; y < H; y += 3) {
                    this.g.beginPath(); this.g.moveTo(0, y); this.g.lineTo(W, y); this.g.strokePath();
                }
                const ry = (Math.sin(this.phase) * 0.5 + 0.5) * H;
                this.g.fillStyle(0xffffff, 0.03);
                this.g.fillRect(0, ry, W, 10);
                this.g.lineStyle(8, 0x000000, 0.18);
                this.g.strokeRect(0, 0, W, H);
            }
        }

        class GameScene extends Phaser.Scene {
            constructor() { super("game"); }

            create() {
                // bullet texture (reliable velocity)
                const gg = this.add.graphics();
                gg.fillStyle(PAL.YELLOW, 1);
                gg.fillCircle(4, 4, 4);
                gg.generateTexture("bullet", 8, 8);
                gg.destroy();

                // physics
                this.G = 170;
                this.physics.world.setBounds(0, 0, W, H);
                this.physics.world.gravity.y = this.G;

                // background
                this.add.rectangle(W / 2, H / 2, W, H, PAL.DKBLUE);

                // ground
                this.groundY = H - 52;
                this.ground = this.add.rectangle(W / 2, this.groundY + 26, W, 52, PAL.DKGREEN);
                this.physics.add.existing(this.ground, true);

                // turret
                this.baseX = W / 2;
                this.baseHPMax = 10;
                this.baseHP = this.baseHPMax;
                this.turret = this.add.rectangle(this.baseX, this.groundY - 10, 72, 32, PAL.GREEN);
                this.barrel = this.add.rectangle(this.baseX, this.groundY - 24, 56, 10, PAL.WHITE).setOrigin(0.12, 0.5);

                // groups
                this.bullets = this.physics.add.group();
                this.air = this.physics.add.group();
                this.troops = this.physics.add.group();     // trooper bodies (circles)
                this.chutes = this.physics.add.group();     // shootable canopy targets
                this.bombs = this.physics.add.group();      // bomber bombs
                this.grounders = this.physics.add.group();  // ground attackers

                // collisions
                this.physics.add.overlap(this.bullets, this.air, this.hitAircraft, null, this);
                this.physics.add.overlap(this.bullets, this.troops, this.hitTroop, null, this);
                this.physics.add.overlap(this.bullets, this.chutes, this.hitChute, null, this);
                this.physics.add.overlap(this.bullets, this.bombs, this.hitBomb, null, this);
                this.physics.add.overlap(this.bullets, this.grounders, this.hitGrounder, null, this);

                this.physics.add.collider(this.troops, this.ground, this.troopLanded, null, this);
                this.physics.add.collider(this.bombs, this.ground, this.bombHitGround, null, this);

                // input
                this.keys = this.input.keyboard.addKeys("SPACE,SHIFT,R");
                this.input.on("pointerdown", () => this.fire(false));
                this.fireCooldown = 0;

                // UI
                this.score = 0;
                this.ui = this.add.text(12, 12, "", { font: "16px monospace", fill: "#dbe8ff" });

                // spawn timing (Atari-ish cadence)
                this.spawnRate = 2200;
                this.nextSpawn = 0;

                // heli drops
                this.heliDropMin = 1000;
                this.heliDropMax = 1600;

                // bomber bombs
                this.bombMin = 900;
                this.bombMax = 1500;

                // landed -> attack rule
                this.landed = [];
                this.attackThreshold = 10;
                this.attackInProgress = false;

                // FX
                this.fx = new AtariFX(this);

                this.updateUI();
            }

            update(time) {
                if (Phaser.Input.Keyboard.JustDown(this.keys.R)) this.scene.restart();

                // aim
                const p = this.input.activePointer;
                let ang = Phaser.Math.Angle.Between(this.barrel.x, this.barrel.y, p.worldX, p.worldY);
                ang = Phaser.Math.Clamp(ang, Phaser.Math.DegToRad(-170), Phaser.Math.DegToRad(-10));
                this.barrel.rotation = ang;

                // fire
                if (Phaser.Input.Keyboard.JustDown(this.keys.SPACE)) this.fire(false);
                if (this.keys.SHIFT.isDown && this.keys.SPACE.isDown) this.fire(true);

                // spawn aircraft (heli + bomber)
                if (time > this.nextSpawn) {
                    this.spawnAircraft(time);
                    this.nextSpawn = time + this.spawnRate;
                }

                // keep deployed parachutes attached to troopers
                this.chutes.children.iterate(ch => {
                    if (!ch || !ch.active) return;
                    const t = ch.trooper;
                    if (!t || !t.active) { ch.destroy(); return; }
                    ch.x = t.x;
                    ch.y = t.y - 16;
                });

                // attackers march & hit base
                this.grounders.children.iterate(a => {
                    if (!a || !a.active) return;
                    const dir = (this.baseX < a.x) ? -1 : 1;
                    a.body.setVelocityX(dir * a.speed);
                    if (Math.abs(a.x - this.baseX) < 30) {
                        a.destroy();
                        this.baseHP = Math.max(0, this.baseHP - 1);
                        this.cameras.main.shake(110, 0.006);
                        this.updateUI();
                        if (this.baseHP <= 0) this.gameOver();
                    }
                });
                if (this.attackInProgress && this.grounders.countActive(true) === 0) this.attackInProgress = false;

                // cleanup
                this.bullets.children.iterate(b => { if (b && b.active && b.y > H + 60) b.destroy(); });
                this.air.children.iterate(a => { if (a && a.active && (a.x < -160 || a.x > W + 160)) a.destroy(); });
                this.troops.children.iterate(t => { if (t && t.active && t.y > H + 90) t.destroy(); });
                this.bombs.children.iterate(b => { if (b && b.active && b.y > H + 90) b.destroy(); });

                this.fx.draw();
            }

            // ---------- firing ----------
            fire(rapid) {
                const now = this.time.now;
                const cd = rapid ? 70 : 120;
                if (now < this.fireCooldown) return;
                this.fireCooldown = now + cd;

                const ang = this.barrel.rotation;
                const x = this.barrel.x + Math.cos(ang) * 48;
                const y = this.barrel.y + Math.sin(ang) * 48;

                const b = this.physics.add.image(x, y, "bullet");
                b.setCollideWorldBounds(true);
                b.body.setCircle(4, 2, 2);

                const speed = 720;
                b.body.setVelocity(Math.cos(ang) * speed, Math.sin(ang) * speed);

                this.bullets.add(b);
                this.time.delayedCall(1800, () => b.destroy());

                this.score = Math.max(0, this.score - 1);
                this.updateUI();
            }

            // ---------- aircraft spawns ----------
            spawnAircraft(time) {
                // Keep heli common; introduce bombers sometimes
                const r = Math.random();
                const type = (r < 0.72) ? "heli" : "bomber";
                if (type === "heli") this.spawnHeli(time);
                else this.spawnBomber(time);
            }

            spawnHeli(time) {
                const left = Math.random() < 0.5;
                const x = left ? -120 : W + 120;
                const y = Phaser.Math.Between(90, 205);

                const body = this.add.rectangle(0, 0, 64, 18, PAL.BLUE);
                const tail = this.add.rectangle(left ? -30 : 30, 0, 26, 6, PAL.PURPLE);
                const rotor = this.add.rectangle(0, -13, 70, 4, PAL.WHITE);

                const heli = this.add.container(x, y, [tail, body, rotor]);
                heli.setSize(84, 34);
                this.physics.add.existing(heli);
                heli.body.setAllowGravity(false);
                heli.body.setVelocityX(left ? 110 : -110);
                heli.kind = "heli";
                heli.hp = 1;

                this.tweens.add({ targets: rotor, angle: 360, duration: 250, repeat: -1 });

                heli.nextDrop = time + Phaser.Math.Between(this.heliDropMin, this.heliDropMax);
                const tick = () => {
                    if (!heli.active || this.baseHP <= 0) return;
                    const now = this.time.now;
                    if (now >= heli.nextDrop) {
                        this.spawnParatrooper(heli.x + Phaser.Math.Between(-10, 10), heli.y + 18, heli.body.velocity.x);
                        heli.nextDrop = now + Phaser.Math.Between(this.heliDropMin, this.heliDropMax);
                    }
                    this.time.delayedCall(120, tick);
                };
                tick();

                this.air.add(heli);
            }

            spawnBomber(time) {
                const left = Math.random() < 0.5;
                const x = left ? -150 : W + 150;
                const y = Phaser.Math.Between(80, 175);

                // bomber silhouette
                const fus = this.add.rectangle(0, 0, 78, 14, PAL.ORANGE).setAlpha(0.95);
                const wing = this.add.rectangle(0, 0, 34, 26, PAL.YELLOW).setAlpha(0.85);
                const tail = this.add.rectangle(left ? -38 : 38, -2, 14, 10, PAL.WHITE).setAlpha(0.8);

                const bomber = this.add.container(x, y, [wing, fus, tail]);
                bomber.setSize(92, 34);
                this.physics.add.existing(bomber);
                bomber.body.setAllowGravity(false);

                const sp = 92; // slower than heli
                bomber.body.setVelocityX(left ? sp : -sp);

                bomber.kind = "bomber";
                bomber.hp = 2;

                bomber.nextBomb = time + Phaser.Math.Between(this.bombMin, this.bombMax);
                const tick = () => {
                    if (!bomber.active || this.baseHP <= 0) return;
                    const now = this.time.now;
                    if (now >= bomber.nextBomb) {
                        this.spawnBomb(bomber.x, bomber.y + 18, bomber.body.velocity.x);
                        bomber.nextBomb = now + Phaser.Math.Between(this.bombMin, this.bombMax);
                    }
                    this.time.delayedCall(120, tick);
                };
                tick();

                this.air.add(bomber);
            }

            spawnBomb(x, y, vx) {
                const bomb = this.add.rectangle(x, y, 10, 14, PAL.ORANGE).setAlpha(0.95);
                this.physics.add.existing(bomb);
                bomb.body.setBounce(0.03);
                bomb.body.setCollideWorldBounds(true);
                bomb.body.setVelocityX(vx * 0.18 + Phaser.Math.Between(-8, 8));
                bomb.body.setVelocityY(Phaser.Math.Between(0, 16));
                this.bombs.add(bomb);
            }

            // ---------- shootable parachutes ----------
            spawnParatrooper(x, y, vx) {
                // physics body
                const body = this.add.circle(x, y, 6, PAL.MAGENTA);
                this.physics.add.existing(body);
                body.body.setCircle(6);
                body.body.setCollideWorldBounds(true);
                body.body.setBounce(0.08);

                body.body.setVelocityX(vx * 0.45 + Phaser.Math.Between(-20, 20));
                body.body.setVelocityY(Phaser.Math.Between(-6, 24));

                body.deployed = false;
                body.chute = null;

                // open after delay -> slow descent
                this.time.delayedCall(200, () => {
                    if (!body.active) return;
                    body.deployed = true;

                    // canopy target (shootable)
                    const chute = this.add.arc(body.x, body.y - 16, 12, 200, -20, false, PAL.WHITE).setAlpha(0.9);
                    this.physics.add.existing(chute);
                    chute.body.setAllowGravity(false);
                    chute.body.setImmovable(true);
                    chute.trooper = body;
                    body.chute = chute;

                    body.body.setGravityY(55);
                    body.body.setMaxVelocity(220, 120);

                    this.tweens.add({ targets: chute, angle: { from: -6, to: 6 }, duration: 520, yoyo: true, repeat: -1, ease: "Sine.easeInOut" });
                    this.chutes.add(chute);
                });

                this.troops.add(body);
            }

            hitChute(bullet, chute) {
                bullet.destroy();

                const t = chute.trooper;
                chute.destroy();

                if (t && t.active) {
                    t.deployed = false;
                    t.chute = null;
                    t.body.setGravityY(this.G);
                    t.body.setMaxVelocity(400, 520);
                    t.body.velocity.y = Math.max(t.body.velocity.y, 120);
                }

                this.score += 40;
                this.updateUI();
            }

            // ---------- landed -> wait -> attack at 10 ----------
            troopLanded(troop) {
                const x = troop.x;

                // cleanup chute if present
                if (troop.chute && troop.chute.active) troop.chute.destroy();

                troop.destroy();

                // waiting marker
                const marker = this.add.rectangle(x, this.groundY - 10, 12, 12, PAL.MAGENTA).setAlpha(0.95);
                this.landed.push({ x, marker });

                if (!this.attackInProgress && this.landed.length >= this.attackThreshold) {
                    this.startAttackWave();
                }
                this.updateUI();
            }

            startAttackWave() {
                this.attackInProgress = true;
                const batch = this.landed.splice(0, this.attackThreshold);

                batch.forEach(entry => {
                    if (entry.marker && entry.marker.active) entry.marker.destroy();

                    const a = this.add.rectangle(entry.x, this.groundY - 10, 14, 14, PAL.MAGENTA).setAlpha(0.95);
                    this.physics.add.existing(a);
                    a.body.setAllowGravity(false);
                    a.body.setCollideWorldBounds(true);
                    a.speed = 22 + Phaser.Math.Between(-3, 3);
                    a.x += Phaser.Math.Between(-6, 6);
                    this.grounders.add(a);
                });
            }

            // ---------- hits ----------
            hitAircraft(bullet, craft) {
                bullet.destroy();
                craft.hp--;
                if (craft.hp <= 0) {
                    craft.destroy();
                    this.score += (craft.kind === "bomber") ? 220 : 140;
                    this.updateUI();
                }
            }

            hitTroop(bullet, troop) {
                bullet.destroy();
                if (troop.chute && troop.chute.active) troop.chute.destroy();
                troop.destroy();
                this.score += 80;
                this.updateUI();
            }

            hitBomb(bullet, bomb) {
                bullet.destroy();
                bomb.destroy();
                this.score += 90;
                this.updateUI();
            }

            hitGrounder(bullet, attacker) {
                bullet.destroy();
                attacker.destroy();
                this.score += 30;
                this.updateUI();
            }

            bombHitGround(bomb) {
                // explode + base damage if close
                const x = bomb.x;
                bomb.destroy();

                const dist = Math.abs(x - this.baseX);
                if (dist < 160) {
                    const dmg = (dist < 80) ? 2 : 1;
                    this.baseHP = Math.max(0, this.baseHP - dmg);
                    this.cameras.main.shake(140, 0.007);
                    this.updateUI();
                    if (this.baseHP <= 0) this.gameOver();
                }
            }

            updateUI() {
                const hpBar = "█".repeat(this.baseHP) + "░".repeat(this.baseHPMax - this.baseHP);
                const waiting = this.landed.length;
                const need = Math.max(0, this.attackThreshold - waiting);
                this.ui.setText(
                    `SCORE ${this.score}\n` +
                    `BASE  ${hpBar}\n` +
                    `LANDED ${waiting}/${this.attackThreshold} (${need} to attack)\n` +
                    `AIR   heli/bomber mix`
                );
            }

            gameOver() {
                this.add.text(W / 2, H / 2, "GAME OVER", { font: "40px monospace", fill: "#f88" }).setOrigin(0.5);
                this.scene.pause();
            }
        }

        new Phaser.Game({
            type: Phaser.AUTO,
            width: W,
            height: H,
            physics: {
                default: "arcade",
                arcade: { gravity: { y: 170 }, debug: false }
            },
            scene: GameScene
        });
    </script>

</body>

</html>